function [Cxy, Pxy, F]=AA_cpsd_mscohere(X, Y, FSx, FSy, varargin)
%% DESCRIPTION:
%
%   Wrapper to generate cross power spectral density, a measure of spectral
%   overlap between two time series of requal length. Also generates the
%   magnitude squared coherence estimate using MATLAB's mscohere function. 
%
%   Computations are performed pairwise between X and all columns (or rows)
%   of Y.
%
%   For details, see 
%   http://www.mathworks.com/help/signal/ug/cross-spectrum-and-magnitude-squared-coherence.html
%   
%   Desired features: 
%       Allow users to pass raw time series, ERP data structures, and
%       filenames pointing to saved ERPs and WAV files. CWB does not think
%       it would be useful to support loading individual EEG datasets.
%
% INPUTS:
%
%   Required:
%
%   X:  can be an Nx1 or 1xN double array. If this is the case, then FSx
%       must be specified. X can also be a full path to a (single channel)
%       wav file or a mat file containing an ERP structure generated by
%       ERPLAB. 
%
%   Y:  Y is similar to X, except that data can be NxS or SxN. Each time
%       series (dimension S) is compared to our reference time series X. Y
%       can also be a vertically concatenated list of ERP file names
%       (useful when generated group level plots). Should also support file
%       names to multiple, single channel Wav files (not thoroughly
%       tested). 
%
%       Note, you do not want to pass ERP.bindata directly as Y if multiple
%       bins are used. The error checking will throw a shoe. Instead, just
%       send the vertically concatenated filenames or arrayed in a cell
%       array and the data will load correctly from file. 
%
%   FSx:    Sampling rate for time series X. Only used if X is a double
%           array. Otherwise, FSx is determined from the wav file or ERP
%           structure.
%
%   FSy:    "" for time series Y. "" Only used if Y is a double array. " "
%
%   Additional parameters:
%
%   Plotting:
%
%       'plev':     integer, plot level (e.g., 1). (Note: this has not been
%                   well tested)
%                       0: no plots generated (tested)
%                       1: group plots generated (tested)
%                       2: group AND subject level plots created (not
%                       implemented as of 3/7/2014)
%       'frange':   two element array specifying the frequency range for
%                   plotting purposes. Note: this does not affect the
%                   actual computations in any way, just the way the data
%                   are visualized. 
%
%   Data clipping:
%
%       'xsig':     two element array specifying the time (in seconds) that
%                   the signal can be found. This is useful when loading
%                   wave files with extended silence at either beginning or
%                   end OR when focusing on the post-stimulus time period
%                   for ERP data structures. (Ex. [0 0.2] | default=[-Inf
%                   Inf])
%       'ysig':     "" but for Y input. (default=[-Inf Inf])
%
%       NOTE:   For ERPs, time point 0 is the first time point of the *pre
%               stimulus* period! Adjust the time window accordingly. 
%
%   ERPs:
%
%       'chans':    channels to load. Required for ERP file names and ERP
%                   structures. (no default)
%       'bins':     bins to load from ERP structure. (Optional; all bins
%                   loaded by default)
%
%   Analysis:
%       
%       'window':   window for cpsd and mscohere. (default=[]); 
%       'antype':   analysis type. ('mscohere' | 'cpsd' | 'all' (default))
%                   If we have analyses that take a very long time, it
%                   might be necessary to specify which analysis is done.
%                   However, with just mscohere and cpsd with short signals
%                   (<20,000 samples), the computations are *very* fast, so
%                   it's not an issue. This flag is here primarily for
%                   future development or in the event that long time
%                   series are necessary. 
%       'noverlap': number of samples by which sections overlap
%                   (default=[])
%       'nfft':     FFT length (default=[]); 
%
% OUTPUTS:
%
%   Cxy:    complex, cross-spectrum power density function.
%   Pxy:    magnitude-squared coherence estimate
%   F:      Frequencies at which Cxy and Pxy are estimated. 
%
% DEVELOPMENT NOTES:
%
%   -Might be useful to perform a time-frequency based CPSD analysis. That
%   is, one that does NOT collapse over section estimates. (low priority).
%
%   - Might be useful to estimate the "apparent latency" of the two
%   signals. Rethink before embarking on this endeavour 
%
% Christopher W. Bishop
%   University of Washington
%   3/14

%% INPUT CHECKS
% Filenames need to be in a cell array
if isa(X, 'char')
    X={X}; 
end % isa(X, 'char')

if isa(Y, 'char')
    % Assume these are vertically concatenated filenames
    for n=1:size(Y,1)
        y{n}=deblank(Y(n,:)); 
    end % for n=1:size(Y,1)
    
    % Reassign Y
    Y=y; 
    clear y; 
end % if 

% Convert inputs to structure
%   Users may also pass a parameter structure directly, which makes CWB's
%   life a lot easier. 
if length(varargin)>1
    p=struct(varargin{:}); 
else 
    p=varargin{1};
end %

% Set default values.
%   Note that p.bins is set in lddata if an ERP structure or ERP filename
%   are provided. 
try p.bins; catch p.bins=[]; end 
try p.chans; catch p.chans=[]; end % will throw a shoe during lddata call.
try p.window; catch p.window=[]; end 
try p.antype; catch p.antype='all'; end 
try p.noverlap; catch p.noverlap=[]; end
try p.nfft; catch p.nfft=[]; end %
try p.xsig; catch p.xsig=[-Inf Inf]; end 
try p.ysig; catch p.ysig=[-Inf Inf]; end 

%% INITIALIZE OUTPUT VARIABLES
F=[]; % Frequency bins
Pxy=[]; % magnitude squared coherence estimate
Cxy=[]; % CPSD estimates

%% LOAD TIME SERIES
% Load reference time series to which all others will be compared
%   This should have a maximum of ONE time series. 
p.maxts=1;
[X, fsx]=AA_loaddata(X,p); 
% [X, fsx]=lddata(X,p);
% Reassign sampling rate if we need to. 
if ~isempty(fsx), FSx=fsx; clear fsx; end 

% Load data to compare to X. Infinite number of time series allowed, but
% will be limited by memory constraints. 
p.maxts=Inf;
[Y, fsy, LABELS]=AA_loaddata(Y,p); 
if ~isempty(fsy), FSy=fsy; clear fsy; end

% Squeeze Y data
%   Often necessary if an ERP structure or filename is loaded. This
%   removes the channel dimension.
if numel(size(Y))>3, Y=squeeze(Y); end 

%% WINDOW DATA
%   Set analysis window as specified by p.xsig and p.ysig
X=windowdata(X, FSx, p.xsig); 
Y=windowdata(Y, FSy, p.ysig); 

%% MASSAGE DATA FOR MSCOHERE AND CPSD
% Match sampling rates
MAXFS= max([FSx FSy]); 
X=resample4TDT(X, MAXFS, FSx);

% Loop call to support multidimensional arrays
y=nan(size(Y)); 
for n=1:size(Y,3)
    y(:,:,n)=resample4TDT(Y(:,:,n), MAXFS, FSy); 
end 
% Reassign
Y=y; 
clear y; 
% Y=resample4TDT(Y, MAXFS, FSy);

% Match stimulus length
MAXLN= max([size(X,1) size(Y,1)]);
X=[X; zeros(MAXLN-size(X,1),size(X,2))];

% Slightly different call to support 3D matrices (e.g., when multiple ERP
% files are passed in as Y. 
%   Initialize a temporary variable as NaNs. Recall that matlab will
%   populate a resized array with zeros by default, which makes it tough to
%   spot errors. With a NaN array, any errors should be easy to spot.
y=nan(MAXLN, size(Y,2), size(Y,3)); 
for n=1:size(Y,3)
    y(:,:,n)=[Y(:,:,n); zeros(MAXLN-size(Y,1),size(Y,2))];
end

% Reassign
Y=y; 
clear y; 

%% COMPUTE MSCOHERE
%   Magnitude-squared coherence.
if strcmpi(p.antype, 'mscohere') || strcmpi(p.antype, 'all')
    for n=1:size(Y,3)
        for i=1:size(Y,2)        
            [pxy, F]=mscohere(X,Y(:,i,n),p.window,p.noverlap,p.nfft, MAXFS);
            Pxy(:,i,n)=pxy; 
            clear pxy            
        end % for i=1:size(Y,2)
    end % for n=1:size(Y,3)
       
    % Set parameter input to set y-axis range
    p.range=[0 1];
    create_plot(F, Pxy, 'Frequency (Hz)', 'Magnitude Squared Coherence', LABELS, p);
    
end % strcmpi(p.antype)

%% COMPUTE CPSD
%   Cross power spectral density
%
%   This computation averages over time windows.
if strcmpi(p.antype, 'cpsd') || strcmpi(p.antype, 'all')
    for n=1:size(Y,3)
        for i=1:size(Y,2)        
            [cxy, F]=cpsd(X,Y(:,i,n),p.window,p.noverlap,p.nfft, MAXFS);
            Cxy(:,i,n)=cxy; 
            clear cxy            
        end % for i=1:size(Y,2)
    end % for n=1:size(Y,3)
    
    % Try to create a plot
    %   Checks to p.plev (plotting level) are made in create_plot.
    p.range=[]; % use whatever autoscale gives us
    create_plot(F, db(abs(Cxy)), 'Frequency (Hz)', 'Power Spectral Density (dB/Hz)', LABELS, p);
        
end % strcmpi(p.antype)

%% ESTIMATE TIME DELAY BETWEEN TWO SIGNALS 
%   Y relative to X (+ values mean that Y starts after X, - values mean
%   that Y starts before X). 
%
%   Estimate phase delay as a measure of latency offset. For broadband
%   stimuli (e.g., speech), might be useful to use a linear fit to
%   unwrapped phase angles vs. frequency plot. 
%
%   Ah, I can see that this is actually suggested in
%
%   Picton, T. W., et al. (2003). "Human auditory steady-state responses." Int J Audiol 42(4): 177-219.
%
%   See "apparent latency" estimates and Figure 2. 
%
%   Limit slope estimate to frequencies that are well-represented in both
%   signals?? (MSCOHERE)?
%
%   Not sure how informative this will be. Reconsider before writing. 

%% TIME-FREQUENCY CPSD
%   Might be helpful to show CPSD as a function of time, rather than
%   averaging over all time windows. 
%   
%   Actually, CWB doesn't think this would be very useful, particularly for
%   temporally offset signals. 
%
%   Reconsider before writing. 

end % AA_cpsd_mscohere

function X=windowdata(X, FS, TWIN)
%% DESCRIPTION:
%
%   Function to window data based on sampling rate and user specified time
%   windows.
%
% INPUT:
%
%   X:  data series as returned from lddata.
%   FS: sampling rate of data
%   TWIN:   two element array specifying the time window. (E.g. [0 Inf]). 
%
% OUTPUT:
%
%   X:  windowed data
%
% Christopher W. Bishop
%   University of Washington 
%   3/14

%% CREATE TIME VECTOR
%   lnspace
t=(0 : 1/FS : size(X,1)/FS-1/FS)';

% Was going to do input checks, but we can't do this easily with Inf and
% -Inf input arguments. So let it throw an uninformative error. 

% %% INPUT CHECKS
% %   Make sure time window fits the stimulus (e.g., window isn't too wide)
% if TWIN(2) > t(end)
%     error('Specified time window is too wide');
% end % if TWIN(2) > t(end)

% Generate a time mask
tmask=AA_maskdomain(t, TWIN); 

% Apply mask
%   Added 3rd dimension argument in the event that multiple ERP files are
%   used (e.g., when creating group averages based on time averaged
%   waveforms. 
X=X(tmask,:,:); 

disp('CWB: Should we use a smarter windowing function (e.g., hamming??). Will likely reduce spectral splatter effects'); 

end % X=windowdata(X, FS, p)

function create_plot(X, Y, XLAB, YLAB, LABELS, p)
%% DESCRIPTION:
%
%   Function to create data plots for AA_cpsd_mscohere. All plots at the
%   time CWB wrote this were almost identical, so CWB decided to modularize
%   the plotting function.
%
% INPUT:
%
%   X:      N double array, x-values.
%   Y:      NxS or NxBxS matrix of y-values. (Note: only tested with NxBxS,
%           the dimensions generated when loading ERP structures as Y in
%           the main function.
%   XLAB:   string, x label
%   YLAB:   string, y label
%   p:      parameter input structure.
%
% OUTPUT:
%
%   A figure, man. A figure.
%
% Christopher W. Bishop
%   University of Washington
%   3/14

% Group level plots
if p.plev>0
    figure, hold on
    
    % Massage NxS data matrix into Nx1xS matrix
    if ndims(Y)==2 %#ok<ISMAT>
        y(:,1,:)=Y;
        Y=y; 
    end % if ndims(X)==2
    
    % Attempt to get appropriate colors with NxS and NxBxS matrices
    [colorDef, styleDef]=erplab_linespec(max([size(Y,2) p.bins]));
    
    %% PLOT SEM
    %   Plotted first for ease of legend labeling. Yes, I know I'm looping
    %   through the data twice. Yes, it is inefficient. No, I don't care.    
    for i=1:size(Y,2) % for each bin we are plotting
        
        % Put data into temporary matrix
        tdata=squeeze(Y(:,i,:)); 
        
        % Plotting SEM when NSEM=0 causes some graphical issues and very
        % slow performance. 
        if p.nsem~=0
            
            % Select color definition
            if ~isempty(p.bins) % && ndims(X)==3
                cdef=colorDef{p.bins(i)};
                sdef=styleDef{p.bins(i)};
            else
                cdef=colorDef{i};
                sdef=styleDef{i};
            end % if ~isempty(p.bins ...
            
            U=mean(tdata,2) + sem(tdata,2).*p.nsem; 
            L=mean(tdata,2) - sem(tdata,2).*p.nsem; 
            ciplot(L, U, X, cdef, 0.15); 
            
        end % if ~NSEM~=0
        
    end % for i=1:size(Y,2)    
    
    % Now plot the individual data traces 
    for i=1:size(Y,2)
        
        % Select color definition
            if ~isempty(p.bins) % && ndims(X)==3
                cdef=colorDef{p.bins(i)};
                sdef=styleDef{p.bins(i)};
            else
                cdef=colorDef{i};
                sdef=styleDef{i};
            end % if ~isempty(p.bins ...
        
        tdata=mean(squeeze(Y(:,i,:)),2); 
        plot(X, tdata, 'Color', cdef, 'LineStyle', sdef, 'linewidth', 1.5);
    end % for i=1:size(A,2)
    
    % Turn on grids
    set(gca, 'XGrid', 'on', 'YGrid', 'on')
    
    % Markup figure
    xlabel(XLAB)
    ylabel(YLAB)
    legend(LABELS, 'Location', 'northeast'); 
    
    % Set title string
    titlstr= ['N=' num2str(size(Y,3)) ' | '];
        
    if ~isempty(p.bins)
        titlstr=[titlstr 'Bins: [' num2str(p.bins) '] | ']; 
    end % if ~isempty(p.bins)

    title(titlstr); 
    
    % Set domain if user specifies it
    if isfield(p, 'frange') && ~isempty(p.frange)
        xlim(p.frange);
    end % if isfield(p, 'frange') ...
    
    % Set range if specified
    if isfield(p, 'range') && ~isempty(p.range)
        ylim(p.range);
    end % if isfield(...
    
end % if p.plev>0
end % function create_plot